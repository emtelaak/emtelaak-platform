import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { protectedProcedure, router } from "./_core/trpc";
import { generate2FASecret, verify2FACode, generateBackupCodes, hashBackupCode, verifyBackupCode, removeUsedBackupCode } from "./_core/twoFactorAuth";
import { getDb } from "./db";
import { users, user2fa } from "../drizzle/schema";
import { eq } from "drizzle-orm";
import { logSecurityEvent } from "./securityDb";
import { COOKIE_NAME, ONE_YEAR_MS } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { sdk } from "./_core/sdk";

export const twoFactorRouter = router({
  /**
   * Setup 2FA for the current user
   * Returns QR code and backup codes
   */
  setup: protectedProcedure.mutation(async ({ ctx }) => {
    const db = await getDb();
    if (!db) {
      throw new Error("Database not available");
    }

    // Generate 2FA secret and QR code
    const setup = await generate2FASecret(ctx.user.email || ctx.user.name || "User");

    // Store secret temporarily (will be confirmed after verification)
    await db
      .update(users)
      .set({ twoFactorSecret: setup.secret })
      .where(eq(users.id, ctx.user.id));

    // Hash backup codes for storage
    const hashedBackupCodes = setup.backupCodes.map(hashBackupCode);

    // Store hashed backup codes
    await db
      .update(users)
      .set({ twoFactorBackupCodes: JSON.stringify(hashedBackupCodes) })
      .where(eq(users.id, ctx.user.id));

    return {
      qrCode: setup.qrCode,
      backupCodes: setup.backupCodes, // Return plain codes for user to save
    };
  }),

  /**
   * Verify and enable 2FA
   * User must provide a valid TOTP code to confirm setup
   */
  enable: protectedProcedure
    .input(z.object({ code: z.string().length(6) }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get user's 2FA secret
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, ctx.user.id))
        .limit(1);

      if (!user || !user.twoFactorSecret) {
        throw new Error("2FA not set up. Please run setup first.");
      }

      // Verify the code
      const isValid = verify2FACode(user.twoFactorSecret, input.code);

      if (!isValid) {
        // Log failed attempt
        await logSecurityEvent({
          eventType: "2fa_failed",
          severity: "medium",
          userId: ctx.user.id,
          email: ctx.user.email,
          details: { action: "enable", reason: "Invalid code" },
        });

        throw new Error("Invalid verification code");
      }

      // Enable 2FA
      await db
        .update(users)
        .set({ twoFactorEnabled: true })
        .where(eq(users.id, ctx.user.id));

      // Log successful enable
      await logSecurityEvent({
        eventType: "2fa_enabled",
        severity: "low",
        userId: ctx.user.id,
        email: ctx.user.email,
        details: { action: "enable" },
      });

      return { success: true };
    }),

  /**
   * Verify 2FA code during login or sensitive operations
   * Also handles remember device functionality
   */
  verifyLogin: protectedProcedure
    .input(z.object({
      code: z.string(),
      rememberDevice: z.boolean().optional(),
    }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get user's 2FA settings
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, ctx.user.id))
        .limit(1);

      if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
        throw new Error("2FA not enabled");
      }

      // Try TOTP code first
      const isValidTOTP = verify2FACode(user.twoFactorSecret, input.code);

      if (isValidTOTP) {
        // Create full session token
        const sessionToken = await sdk.createSessionToken(user.openId, {
          name: user.name || "",
          expiresInMs: ONE_YEAR_MS,
        });

        const cookieOptions = getSessionCookieOptions(ctx.req);
        
        // Set full session cookie
        ctx.res.cookie(COOKIE_NAME, sessionToken, { ...cookieOptions, maxAge: ONE_YEAR_MS });
        
        // Clear temporary cookies
        ctx.res.clearCookie("temp_session", cookieOptions);
        ctx.res.clearCookie("requires_2fa", cookieOptions);

        return {
          success: true,
          method: "totp",
          rememberDevice: input.rememberDevice || false,
        };
      }

      // Try backup code
      const backupCodes = user.twoFactorBackupCodes
        ? JSON.parse(user.twoFactorBackupCodes)
        : [];

      const isValidBackup = verifyBackupCode(input.code, backupCodes);

      if (isValidBackup) {
        // Remove used backup code
        const updatedCodes = removeUsedBackupCode(input.code, backupCodes);

        await db
          .update(users)
          .set({ twoFactorBackupCodes: JSON.stringify(updatedCodes) })
          .where(eq(users.id, ctx.user.id));

        // Log backup code usage
        await logSecurityEvent({
          eventType: "2fa_backup_used",
          severity: "medium",
          userId: ctx.user.id,
          email: ctx.user.email,
          details: { remainingCodes: updatedCodes.length },
        });

        // Create full session token
        const sessionToken = await sdk.createSessionToken(user.openId, {
          name: user.name || "",
          expiresInMs: ONE_YEAR_MS,
        });

        const cookieOptions = getSessionCookieOptions(ctx.req);
        
        // Set full session cookie
        ctx.res.cookie(COOKIE_NAME, sessionToken, { ...cookieOptions, maxAge: ONE_YEAR_MS });
        
        // Clear temporary cookies
        ctx.res.clearCookie("temp_session", cookieOptions);
        ctx.res.clearCookie("requires_2fa", cookieOptions);

        return {
          success: true,
          method: "backup",
          remainingBackupCodes: updatedCodes.length,
          rememberDevice: input.rememberDevice || false,
        };
      }

      // Log failed verification
      await logSecurityEvent({
        eventType: "2fa_failed",
        severity: "high",
        userId: ctx.user.id,
        email: ctx.user.email,
        details: { action: "verify_login" },
      });

      throw new Error("Invalid verification code");
    }),

  /**
   * Verify 2FA code during login or sensitive operations
   */
  verify: protectedProcedure
    .input(z.object({ code: z.string() }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get user's 2FA settings
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, ctx.user.id))
        .limit(1);

      if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
        throw new Error("2FA not enabled");
      }

      // Try TOTP code first
      const isValidTOTP = verify2FACode(user.twoFactorSecret, input.code);

      if (isValidTOTP) {
        return { success: true, method: "totp" };
      }

      // Try backup code
      const backupCodes = user.twoFactorBackupCodes
        ? JSON.parse(user.twoFactorBackupCodes)
        : [];

      const isValidBackup = verifyBackupCode(input.code, backupCodes);

      if (isValidBackup) {
        // Remove used backup code
        const updatedCodes = removeUsedBackupCode(input.code, backupCodes);

        await db
          .update(users)
          .set({ twoFactorBackupCodes: JSON.stringify(updatedCodes) })
          .where(eq(users.id, ctx.user.id));

        // Log backup code usage
        await logSecurityEvent({
          eventType: "2fa_backup_used",
          severity: "medium",
          userId: ctx.user.id,
          email: ctx.user.email,
          details: { remainingCodes: updatedCodes.length },
        });

        return { success: true, method: "backup", remainingBackupCodes: updatedCodes.length };
      }

      // Log failed verification
      await logSecurityEvent({
        eventType: "2fa_failed",
        severity: "high",
        userId: ctx.user.id,
        email: ctx.user.email,
        details: { action: "verify" },
      });

      throw new Error("Invalid verification code");
    }),

  /**
   * Disable 2FA
   * Requires current password or 2FA code for security
   */
  disable: protectedProcedure
    .input(z.object({ code: z.string() }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get user's 2FA settings
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, ctx.user.id))
        .limit(1);

      if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
        throw new Error("2FA not enabled");
      }

      // Verify code before disabling
      const isValid = verify2FACode(user.twoFactorSecret, input.code);

      if (!isValid) {
        throw new Error("Invalid verification code");
      }

      // Disable 2FA and clear secrets
      await db
        .update(users)
        .set({
          twoFactorEnabled: false,
          twoFactorSecret: null,
          twoFactorBackupCodes: null,
        })
        .where(eq(users.id, ctx.user.id));

      // Log disable action
      await logSecurityEvent({
        eventType: "2fa_disabled",
        severity: "medium",
        userId: ctx.user.id,
        email: ctx.user.email,
        details: { action: "disable" },
      });

      return { success: true };
    }),

  /**
   * Regenerate backup codes
   * Requires 2FA code for security
   */
  regenerateBackupCodes: protectedProcedure
    .input(z.object({ code: z.string().length(6) }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get user's 2FA settings
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, ctx.user.id))
        .limit(1);

      if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
        throw new Error("2FA not enabled");
      }

      // Verify code before regenerating
      const isValid = verify2FACode(user.twoFactorSecret, input.code);

      if (!isValid) {
        throw new Error("Invalid verification code");
      }

      // Generate new backup codes
      const newBackupCodes = generateBackupCodes(10);
      const hashedCodes = newBackupCodes.map(hashBackupCode);

      await db
        .update(users)
        .set({ twoFactorBackupCodes: JSON.stringify(hashedCodes) })
        .where(eq(users.id, ctx.user.id));

      // Log regeneration
      await logSecurityEvent({
        eventType: "2fa_backup_regenerated",
        severity: "low",
        userId: ctx.user.id,
        email: ctx.user.email,
        details: { action: "regenerate_backup_codes" },
      });

      return { backupCodes: newBackupCodes };
    }),

  /**
   * Get 2FA status for current user
   */
  getStatus: protectedProcedure.query(async ({ ctx }) => {
    const db = await getDb();
    if (!db) {
      return { enabled: false };
    }

    const [user] = await db
      .select({
        twoFactorEnabled: users.twoFactorEnabled,
        twoFactorBackupCodes: users.twoFactorBackupCodes,
      })
      .from(users)
      .where(eq(users.id, ctx.user.id))
      .limit(1);

    if (!user) {
      return { enabled: false };
    }

    const backupCodes = user.twoFactorBackupCodes
      ? JSON.parse(user.twoFactorBackupCodes)
      : [];

    return {
      enabled: user.twoFactorEnabled || false,
      backupCodesCount: backupCodes.length,
    };
  }),

  /**
   * Admin: Toggle 2FA for any user
   * Requires admin role
   */
  adminToggleUser2FA: protectedProcedure
    .input(z.object({
      userId: z.number(),
      enabled: z.boolean(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Check if current user is admin
      if (ctx.user.role !== 'admin') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only admins can manage user 2FA settings',
        });
      }

      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get target user
      const [targetUser] = await db
        .select()
        .from(users)
        .where(eq(users.id, input.userId))
        .limit(1);

      if (!targetUser) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }

      // Update 2FA status
      await db
        .update(users)
        .set({ twoFactorEnabled: input.enabled })
        .where(eq(users.id, input.userId));

      // Log security event
      await logSecurityEvent({
        eventType: 'suspicious_activity',
        severity: 'high',
        userId: input.userId,
        ipAddress: 'admin_action',
        userAgent: 'admin_dashboard',
        details: `Admin ${ctx.user.name} (ID: ${ctx.user.id}) ${input.enabled ? 'enabled' : 'disabled'} 2FA for user ${targetUser.name} (ID: ${input.userId})`,
      });

      return {
        success: true,
        message: `2FA ${input.enabled ? 'enabled' : 'disabled'} for user ${targetUser.name}`,
      };
    }),

  /**
   * Admin: Reset 2FA for any user
   * Clears 2FA secret and backup codes, disables 2FA
   */
  adminResetUser2FA: protectedProcedure
    .input(z.object({
      userId: z.number(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Check if current user is admin
      if (ctx.user.role !== 'admin') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Only admins can reset user 2FA',
        });
      }

      const db = await getDb();
      if (!db) {
        throw new Error("Database not available");
      }

      // Get target user
      const [targetUser] = await db
        .select()
        .from(users)
        .where(eq(users.id, input.userId))
        .limit(1);

      if (!targetUser) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }

      // Reset 2FA completely
      await db
        .update(users)
        .set({
          twoFactorEnabled: false,
          twoFactorSecret: null,
          twoFactorBackupCodes: null,
        })
        .where(eq(users.id, input.userId));

      // Log security event
      await logSecurityEvent({
        eventType: 'suspicious_activity',
        severity: 'critical',
        userId: input.userId,
        ipAddress: 'admin_action',
        userAgent: 'admin_dashboard',
        details: `Admin ${ctx.user.name} (ID: ${ctx.user.id}) reset 2FA for user ${targetUser.name} (ID: ${input.userId})`,
      });

      return {
        success: true,
        message: `2FA reset for user ${targetUser.name}`,
      };
    }),
});
